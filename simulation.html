<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>염수분사장치 시뮬레이션</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #0a0e1a;
  color: #e0e0e0;
  font-family: 'Segoe UI', sans-serif;
  overflow: hidden;
  height: 100vh;
}

/* ── 레이아웃 ── */
.app {
  display: grid;
  grid-template-columns: 300px 1fr 320px;
  grid-template-rows: 56px 1fr 48px;
  height: 100vh;
}

/* ── 헤더 ── */
.header {
  grid-column: 1 / -1;
  background: #111827;
  border-bottom: 1px solid #1e293b;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 20px;
}
.header h1 { font-size: 16px; font-weight: 600; color: #60a5fa; }
.header .status {
  display: flex;
  align-items: center;
  gap: 12px;
  font-size: 13px;
}
.header .status .dot {
  width: 8px; height: 8px;
  border-radius: 50%;
  background: #22c55e;
  animation: pulse 2s infinite;
}
@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.4; }
}

/* ── 좌측 패널: 파라미터 ── */
.panel-left {
  background: #111827;
  border-right: 1px solid #1e293b;
  padding: 16px;
  overflow-y: auto;
}
.panel-left h2 {
  font-size: 13px;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: #60a5fa;
  margin-bottom: 12px;
}
.param-group {
  margin-bottom: 16px;
  padding-bottom: 12px;
  border-bottom: 1px solid #1e293b;
}
.param-group label {
  display: block;
  font-size: 11px;
  color: #94a3b8;
  margin-bottom: 4px;
  margin-top: 8px;
}
.param-group input[type="range"] {
  width: 100%;
  accent-color: #60a5fa;
}
.param-group .value {
  font-size: 12px;
  color: #60a5fa;
  float: right;
  font-weight: 600;
}
.param-group select {
  width: 100%;
  background: #1e293b;
  color: #e0e0e0;
  border: 1px solid #334155;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
}

/* ── 중앙: 시뮬레이션 뷰 ── */
.sim-view {
  position: relative;
  background: #0f172a;
  overflow: hidden;
}
.sim-view canvas {
  width: 100%;
  height: 100%;
}

/* ── 우측 패널: 판정 ── */
.panel-right {
  background: #111827;
  border-left: 1px solid #1e293b;
  padding: 16px;
  overflow-y: auto;
}
.panel-right h2 {
  font-size: 13px;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: #60a5fa;
  margin-bottom: 12px;
}

.verdict-box {
  text-align: center;
  padding: 16px;
  border-radius: 8px;
  margin-bottom: 16px;
  font-size: 24px;
  font-weight: 800;
  letter-spacing: 2px;
}
.verdict-FAIL { background: #450a0a; color: #f87171; border: 2px solid #dc2626; }
.verdict-PASS { background: #052e16; color: #4ade80; border: 2px solid #16a34a; }
.verdict-CONDITIONAL { background: #422006; color: #fbbf24; border: 2px solid #d97706; }

.stat-row {
  display: flex;
  justify-content: space-between;
  padding: 6px 0;
  font-size: 12px;
  border-bottom: 1px solid #1e293b;
}
.stat-row .label { color: #94a3b8; }
.stat-row .val { color: #e0e0e0; font-weight: 600; }
.stat-row .val.critical { color: #f87171; }
.stat-row .val.warning { color: #fbbf24; }
.stat-row .val.good { color: #4ade80; }

.failure-item {
  background: #1e1215;
  border-left: 3px solid #dc2626;
  padding: 8px 10px;
  margin-bottom: 8px;
  border-radius: 0 4px 4px 0;
  font-size: 11px;
}
.failure-item.warn {
  background: #1e1a0f;
  border-left-color: #d97706;
}
.failure-item .title { font-weight: 600; color: #f87171; }
.failure-item.warn .title { color: #fbbf24; }
.failure-item .desc { color: #94a3b8; margin-top: 4px; }

/* ── 하단 바 ── */
.footer {
  grid-column: 1 / -1;
  background: #111827;
  border-top: 1px solid #1e293b;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 16px;
  padding: 0 20px;
}
.btn {
  background: #1e293b;
  color: #e0e0e0;
  border: 1px solid #334155;
  padding: 6px 20px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 13px;
  transition: all 0.2s;
}
.btn:hover { background: #334155; }
.btn.primary { background: #2563eb; border-color: #3b82f6; color: #fff; }
.btn.primary:hover { background: #1d4ed8; }
.btn.danger { background: #991b1b; border-color: #dc2626; }

.time-display {
  font-size: 13px;
  color: #60a5fa;
  font-family: monospace;
}

/* ── 환경 오버레이 ── */
.env-overlay {
  position: absolute;
  top: 12px;
  left: 12px;
  background: rgba(17, 24, 39, 0.85);
  padding: 10px 14px;
  border-radius: 6px;
  font-size: 11px;
  line-height: 1.6;
  pointer-events: none;
  border: 1px solid #1e293b;
  z-index: 10;
}
.env-overlay .env-title { color: #60a5fa; font-weight: 600; margin-bottom: 4px; }

/* ── 범례 ── */
.legend {
  position: absolute;
  bottom: 12px;
  left: 12px;
  background: rgba(17, 24, 39, 0.85);
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 11px;
  border: 1px solid #1e293b;
  z-index: 10;
}
.legend-item {
  display: flex;
  align-items: center;
  gap: 8px;
  margin: 3px 0;
}
.legend-color {
  width: 14px; height: 14px;
  border-radius: 2px;
}

/* ── 눈 효과 ── */
.snow-canvas {
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
  z-index: 5;
}
</style>
</head>
<body>
<div class="app">

  <!-- 헤더 -->
  <div class="header">
    <h1>Problem-Driven BIM Simulation Engine / Brine Spray System</h1>
    <div class="status">
      <div class="dot"></div>
      <span id="simStatus">READY</span>
    </div>
  </div>

  <!-- 좌측: 파라미터 -->
  <div class="panel-left">
    <h2>Environment</h2>
    <div class="param-group">
      <label>Location Preset</label>
      <select id="presetSelect">
        <option value="gangwon_winter_night">Gangwon - Winter Night</option>
        <option value="seoul_winter_night">Seoul - Winter Night</option>
        <option value="seoul_winter_dawn">Seoul - Winter Dawn</option>
        <option value="busan_winter_morning">Busan - Winter Morning</option>
        <option value="daejeon_winter_dawn">Daejeon - Winter Dawn</option>
      </select>
    </div>
    <div class="param-group">
      <label>Air Temperature <span class="value" id="tempVal">-15 C</span></label>
      <input type="range" id="tempSlider" min="-25" max="5" value="-15" step="1">
      <label>Wind Speed <span class="value" id="windVal">5.0 m/s</span></label>
      <input type="range" id="windSlider" min="0" max="15" value="5" step="0.5">
      <label>Snowfall <span class="value" id="snowVal">5.0 mm/h</span></label>
      <input type="range" id="snowSlider" min="0" max="20" value="5" step="0.5">
    </div>

    <h2>Road</h2>
    <div class="param-group">
      <label>Road Length <span class="value" id="roadLenVal">200 m</span></label>
      <input type="range" id="roadLenSlider" min="50" max="500" value="200" step="10">
      <label>Lanes <span class="value" id="lanesVal">2</span></label>
      <input type="range" id="lanesSlider" min="1" max="6" value="2" step="1">
      <label>Slope <span class="value" id="slopeVal">3.0 %</span></label>
      <input type="range" id="slopeSlider" min="0" max="12" value="3" step="0.5">
    </div>

    <h2>Spray Devices</h2>
    <div class="param-group">
      <label>Number of Devices <span class="value" id="devCountVal">3</span></label>
      <input type="range" id="devCountSlider" min="1" max="20" value="3" step="1">
      <label>Spray Range <span class="value" id="sprayRangeVal">8.0 m</span></label>
      <input type="range" id="sprayRangeSlider" min="2" max="20" value="8" step="0.5">
      <label>Spray Angle <span class="value" id="sprayAngleVal">120 deg</span></label>
      <input type="range" id="sprayAngleSlider" min="30" max="360" value="120" step="10">
      <label>Burial Depth <span class="value" id="burialVal">400 mm</span></label>
      <input type="range" id="burialSlider" min="0" max="1200" value="400" step="50">
      <label>Flow Rate <span class="value" id="flowVal">5.0 L/min</span></label>
      <input type="range" id="flowSlider" min="1" max="20" value="5" step="0.5">
    </div>
  </div>

  <!-- 중앙: 시뮬레이션 -->
  <div class="sim-view">
    <canvas id="simCanvas"></canvas>
    <canvas class="snow-canvas" id="snowCanvas"></canvas>
    <div class="env-overlay" id="envOverlay"></div>
    <div class="legend">
      <div class="legend-item"><div class="legend-color" style="background:#3b82f6"></div> Effective Coverage</div>
      <div class="legend-item"><div class="legend-color" style="background:#60a5fa44"></div> Partial Coverage</div>
      <div class="legend-item"><div class="legend-color" style="background:#ef4444"></div> Uncovered Zone</div>
      <div class="legend-item"><div class="legend-color" style="background:#fbbf24"></div> Spray Device</div>
      <div class="legend-item"><div class="legend-color" style="background:#a855f7"></div> Wind Drift</div>
    </div>
  </div>

  <!-- 우측: 판정 -->
  <div class="panel-right">
    <h2>Judgment</h2>
    <div class="verdict-box verdict-FAIL" id="verdictBox">FAIL</div>

    <h2>Statistics</h2>
    <div id="statsContainer"></div>

    <h2 style="margin-top:16px">Failures</h2>
    <div id="failuresContainer"></div>

    <h2 style="margin-top:16px">Ice Risk</h2>
    <div style="margin-bottom:16px;">
      <div style="background:#1e293b; border-radius:4px; height:24px; overflow:hidden;">
        <div id="iceRiskBar" style="height:100%; width:100%; background:linear-gradient(90deg,#dc2626,#f87171); transition:width 0.5s;"></div>
      </div>
      <div style="text-align:center; font-size:12px; margin-top:4px;" id="iceRiskText">100%</div>
    </div>
  </div>

  <!-- 하단 -->
  <div class="footer">
    <button class="btn primary" id="btnRun">Run Simulation</button>
    <button class="btn" id="btnReset">Reset</button>
    <span class="time-display" id="timeDisplay">T: 00:00</span>
  </div>

</div>

<script>
// ═══════════════════════════════════════════════════
//  시뮬레이션 엔진 (JavaScript 이식)
// ═══════════════════════════════════════════════════

const PRESETS = {
  gangwon_winter_night: { temp: -15, roadTemp: -18, humidity: 75, wind: 5, windDir: 270, precip: 'snow', precipMm: 5, solar: 0, cloud: 95 },
  seoul_winter_night: { temp: -8, roadTemp: -10, humidity: 65, wind: 3.5, windDir: 315, precip: 'snow', precipMm: 2, solar: 0, cloud: 90 },
  seoul_winter_dawn: { temp: -12, roadTemp: -15, humidity: 70, wind: 1.5, windDir: 0, precip: 'none', precipMm: 0, solar: 0, cloud: 30 },
  busan_winter_morning: { temp: -2, roadTemp: -3, humidity: 80, wind: 6, windDir: 180, precip: 'freezing_rain', precipMm: 1.5, solar: 50, cloud: 80 },
  daejeon_winter_dawn: { temp: -6, roadTemp: -9, humidity: 60, wind: 2, windDir: 0, precip: 'none', precipMm: 0, solar: 0, cloud: 20 },
};

const FROST_DEPTHS = { gangwon: 900, seoul: 600, busan: 300, daejeon: 500 };

function getParams() {
  return {
    preset: document.getElementById('presetSelect').value,
    temp: +document.getElementById('tempSlider').value,
    wind: +document.getElementById('windSlider').value,
    snow: +document.getElementById('snowSlider').value,
    roadLen: +document.getElementById('roadLenSlider').value,
    lanes: +document.getElementById('lanesSlider').value,
    slope: +document.getElementById('slopeSlider').value,
    devCount: +document.getElementById('devCountSlider').value,
    sprayRange: +document.getElementById('sprayRangeSlider').value,
    sprayAngle: +document.getElementById('sprayAngleSlider').value,
    burial: +document.getElementById('burialSlider').value,
    flow: +document.getElementById('flowSlider').value,
  };
}

function simulate(p) {
  const preset = PRESETS[p.preset];
  const roadWidth = 3.5 * p.lanes;
  const totalArea = p.roadLen * roadWidth;
  const halfRoad = roadWidth / 2;

  // 장치 등간격 배치
  const devices = [];
  const spacing = p.roadLen / (p.devCount + 1);
  for (let i = 0; i < p.devCount; i++) {
    devices.push({ id: `SPR-${String(i+1).padStart(3,'0')}`, pos: spacing * (i + 1) });
  }

  // 바람 편류
  const driftFactor = 0.05;
  const windCross = Math.sin(preset.windDir * Math.PI / 180);
  const drift = p.wind * p.sprayRange * driftFactor * windCross;

  // 온도 효율
  let tempEff = 1.0;
  if (p.temp < -10) tempEff = 0.7;
  else if (p.temp < -5) tempEff = 0.85;
  else if (p.temp < 0) tempEff = 0.95;
  const effRange = p.sprayRange * tempEff;

  // 커버리지 그리드 (1m 해상도)
  const grid = {};
  const res = 1.0;

  for (const dev of devices) {
    const cx = dev.pos;
    const cy = drift;
    const halfAngle = (p.sprayAngle / 2) * Math.PI / 180;
    const sprayWidth = effRange * Math.tan(halfAngle);

    for (let x = cx - effRange; x <= cx + effRange; x += res) {
      for (let y = -sprayWidth + cy; y <= sprayWidth + cy; y += res) {
        if (x < 0 || x > p.roadLen) continue;
        if (Math.abs(y) > halfRoad) continue;
        const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
        if (dist > effRange || dist < 0.1) continue;
        const intensity = 1.0 - (dist / effRange);
        const amount = intensity * p.flow * 10 / Math.max(1, dist ** 1.2);
        const key = `${Math.round(x)},${Math.round(y)}`;
        grid[key] = Math.max(grid[key] || 0, amount);
      }
    }
  }

  // 커버리지 분석
  let coveredCount = 0;
  const coveredXSet = new Set();
  const allX = new Set();
  for (let x = 0; x <= p.roadLen; x += res) {
    allX.add(x);
  }

  for (const [key, val] of Object.entries(grid)) {
    if (val >= 20.0) {
      coveredCount++;
      coveredXSet.add(+key.split(',')[0]);
    }
  }

  const coveredArea = coveredCount * res * res;
  const coverageRatio = coveredArea / totalArea;

  // 미커버 구간
  const uncoveredZones = [];
  let zoneStart = null;
  for (let x = 0; x <= p.roadLen; x += res) {
    if (!coveredXSet.has(x)) {
      if (zoneStart === null) zoneStart = x;
    } else {
      if (zoneStart !== null) {
        if (x - zoneStart > 5) uncoveredZones.push([zoneStart, x]);
        zoneStart = null;
      }
    }
  }
  if (zoneStart !== null && p.roadLen - zoneStart > 5) {
    uncoveredZones.push([zoneStart, p.roadLen]);
  }

  // 결빙 위험
  let iceRisk = 0;
  const roadTemp = p.temp - 2;
  if (roadTemp <= 0) { iceRisk += 0.4; iceRisk += Math.min(0.3, Math.abs(roadTemp) * 0.02); }
  if (preset.humidity > 70) iceRisk += 0.1;
  if (['snow','sleet','freezing_rain'].includes(preset.precip)) iceRisk += 0.2;
  if (p.wind < 2 && preset.cloud < 30) iceRisk += 0.1;
  iceRisk = Math.min(1, iceRisk);

  // 동파 판정
  const region = p.preset.split('_')[0];
  const frostDepth = FROST_DEPTHS[region] || 600;
  const frostRisk = p.burial > 0 && p.burial < frostDepth;

  // 판정
  const failures = [];
  if (coverageRatio < 0.5) failures.push({ sev: 'critical', title: 'COV-001 Coverage Critical', desc: `${(coverageRatio*100).toFixed(1)}% (min 80%)` });
  else if (coverageRatio < 0.8) failures.push({ sev: 'warning', title: 'COV-002 Coverage Low', desc: `${(coverageRatio*100).toFixed(1)}% (min 80%)` });

  for (const z of uncoveredZones) {
    if (z[1] - z[0] > 10) failures.push({ sev: 'critical', title: `GAP-001 Uncovered ${z[0]}~${z[1]}m`, desc: `${(z[1]-z[0]).toFixed(0)}m gap (max 10m)` });
  }

  if (Math.abs(drift) > effRange * 0.3) failures.push({ sev: 'warning', title: 'WIND-001 Spray Drift', desc: `${drift.toFixed(1)}m drift at ${p.wind}m/s` });
  if (frostRisk) failures.push({ sev: 'critical', title: 'FROST-001 Freeze Risk', desc: `Burial ${p.burial}mm < frost depth ${frostDepth}mm` });
  if (Math.abs(p.slope) > 5) failures.push({ sev: 'warning', title: 'SLOPE-001 Steep Grade', desc: `${p.slope}% slope affects brine flow` });

  const criticals = failures.filter(f => f.sev === 'critical').length;
  let verdict = 'PASS';
  if (criticals > 0) verdict = 'FAIL';
  else if (failures.length > 0) verdict = 'CONDITIONAL';

  return {
    devices, drift, effRange, grid, halfRoad, roadWidth,
    totalArea, coveredArea, coverageRatio, uncoveredZones,
    iceRisk, frostDepth, frostRisk, failures, verdict,
    criticals, warnings: failures.filter(f => f.sev === 'warning').length,
  };
}


// ═══════════════════════════════════════════════════
//  렌더링
// ═══════════════════════════════════════════════════

const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const snowCanvas = document.getElementById('snowCanvas');
const snowCtx = snowCanvas.getContext('2d');

let simResult = null;
let animFrame = 0;
let isRunning = false;
let simTime = 0;
let snowflakes = [];

function resizeCanvas() {
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width;
  canvas.height = rect.height;
  snowCanvas.width = rect.width;
  snowCanvas.height = rect.height;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function worldToScreen(x, y, p) {
  const padding = 60;
  const availW = canvas.width - padding * 2;
  const availH = canvas.height - padding * 2;
  const scaleX = availW / p.roadLen;
  const roadWidth = 3.5 * p.lanes;
  const scaleY = availH / (roadWidth + 20);
  const scale = Math.min(scaleX, scaleY);

  const sx = padding + (x / p.roadLen) * availW;
  const sy = canvas.height / 2 + y * scale;
  return [sx, sy, scale];
}

function drawSimulation(p, result) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const padding = 60;
  const availW = canvas.width - padding * 2;
  const availH = canvas.height - padding * 2;
  const roadWidth = 3.5 * p.lanes;
  const scaleX = availW / p.roadLen;
  const scaleY = availH / (roadWidth + 20);
  const scale = Math.min(scaleX, scaleY);
  const roadH = roadWidth * scale;
  const roadY = canvas.height / 2 - roadH / 2;

  // 도로 배경
  ctx.fillStyle = '#1e293b';
  ctx.fillRect(padding, roadY - 10, availW, roadH + 20);

  // 도로 표면
  ctx.fillStyle = '#374151';
  ctx.fillRect(padding, roadY, availW, roadH);

  // 차선
  ctx.setLineDash([20, 15]);
  ctx.strokeStyle = '#fbbf2488';
  ctx.lineWidth = 2;
  for (let i = 1; i < p.lanes; i++) {
    const ly = roadY + (roadH / p.lanes) * i;
    ctx.beginPath();
    ctx.moveTo(padding, ly);
    ctx.lineTo(padding + availW, ly);
    ctx.stroke();
  }
  ctx.setLineDash([]);

  // 도로 경계선
  ctx.strokeStyle = '#f8fafc';
  ctx.lineWidth = 2;
  ctx.strokeRect(padding, roadY, availW, roadH);

  // 커버리지 히트맵
  const cellW = availW / p.roadLen;
  const cellH = roadH / roadWidth;
  for (const [key, val] of Object.entries(result.grid)) {
    const [gx, gy] = key.split(',').map(Number);
    const sx = padding + (gx / p.roadLen) * availW;
    const sy = canvas.height / 2 + gy * scale;

    if (val >= 20) {
      const alpha = Math.min(0.8, val / 100);
      ctx.fillStyle = `rgba(59, 130, 246, ${alpha})`;
    } else if (val > 5) {
      ctx.fillStyle = `rgba(96, 165, 250, 0.15)`;
    } else {
      continue;
    }
    ctx.fillRect(sx - cellW/2, sy - cellH/2, Math.max(cellW, 2), Math.max(cellH, 2));
  }

  // 미커버 구간 강조
  for (const [zStart, zEnd] of result.uncoveredZones) {
    const sx = padding + (zStart / p.roadLen) * availW;
    const ex = padding + (zEnd / p.roadLen) * availW;
    ctx.fillStyle = 'rgba(239, 68, 68, 0.15)';
    ctx.fillRect(sx, roadY, ex - sx, roadH);
    ctx.strokeStyle = '#ef4444';
    ctx.lineWidth = 1;
    ctx.setLineDash([5, 5]);
    ctx.strokeRect(sx, roadY, ex - sx, roadH);
    ctx.setLineDash([]);

    // 라벨
    ctx.fillStyle = '#f87171';
    ctx.font = '10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`${(zEnd-zStart).toFixed(0)}m uncovered`, (sx + ex) / 2, roadY - 14);
  }

  // 분사 장치
  for (const dev of result.devices) {
    const dx = padding + (dev.pos / p.roadLen) * availW;
    const dy = canvas.height / 2;

    // 분사 범위 (부채꼴)
    const halfAngle = (p.sprayAngle / 2) * Math.PI / 180;
    const rangePixels = result.effRange * scale;

    // 편류 표시
    if (Math.abs(result.drift) > 0.5) {
      const driftPx = result.drift * scale;
      ctx.strokeStyle = '#a855f7';
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 3]);
      ctx.beginPath();
      ctx.moveTo(dx, dy);
      ctx.lineTo(dx, dy + driftPx);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // 분사 아크 애니메이션
    const pulse = 0.85 + 0.15 * Math.sin(animFrame * 0.05 + dev.pos);

    ctx.save();
    ctx.translate(dx, dy + result.drift * scale);
    // 좌측 분사
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.arc(0, 0, rangePixels * pulse, -Math.PI/2 - halfAngle, -Math.PI/2 + halfAngle);
    ctx.closePath();
    const grad1 = ctx.createRadialGradient(0, 0, 0, 0, 0, rangePixels * pulse);
    grad1.addColorStop(0, 'rgba(59, 130, 246, 0.4)');
    grad1.addColorStop(1, 'rgba(59, 130, 246, 0.02)');
    ctx.fillStyle = grad1;
    ctx.fill();

    // 우측 분사
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.arc(0, 0, rangePixels * pulse, Math.PI/2 - halfAngle, Math.PI/2 + halfAngle);
    ctx.closePath();
    ctx.fillStyle = grad1;
    ctx.fill();
    ctx.restore();

    // 장치 아이콘
    ctx.beginPath();
    ctx.arc(dx, dy, 6, 0, Math.PI * 2);
    ctx.fillStyle = '#fbbf24';
    ctx.fill();
    ctx.strokeStyle = '#f59e0b';
    ctx.lineWidth = 2;
    ctx.stroke();

    // 장치 라벨
    ctx.fillStyle = '#fbbf24';
    ctx.font = 'bold 10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(dev.id, dx, roadY + roadH + 20);
  }

  // 거리 눈금
  ctx.fillStyle = '#64748b';
  ctx.font = '10px monospace';
  ctx.textAlign = 'center';
  const step = p.roadLen <= 100 ? 10 : p.roadLen <= 300 ? 25 : 50;
  for (let m = 0; m <= p.roadLen; m += step) {
    const sx = padding + (m / p.roadLen) * availW;
    ctx.fillText(`${m}m`, sx, roadY + roadH + 36);
    ctx.fillStyle = '#334155';
    ctx.fillRect(sx, roadY + roadH, 1, 4);
    ctx.fillStyle = '#64748b';
  }

  // 바람 화살표
  if (p.wind > 0) {
    const windX = canvas.width - 100;
    const windY = 30;
    ctx.save();
    ctx.translate(windX, windY);
    const preset = PRESETS[p.preset];
    const wDir = (preset.windDir - 90) * Math.PI / 180;
    ctx.rotate(wDir);
    const arrowLen = 20 + p.wind * 2;
    ctx.strokeStyle = '#94a3b8';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-arrowLen/2, 0);
    ctx.lineTo(arrowLen/2, 0);
    ctx.lineTo(arrowLen/2 - 8, -5);
    ctx.moveTo(arrowLen/2, 0);
    ctx.lineTo(arrowLen/2 - 8, 5);
    ctx.stroke();
    ctx.restore();
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`Wind ${p.wind}m/s`, windX, windY + 24);
  }

  animFrame++;
}


// ═══════════════════════════════════════════════════
//  눈 효과
// ═══════════════════════════════════════════════════

function initSnow(count) {
  snowflakes = [];
  for (let i = 0; i < count; i++) {
    snowflakes.push({
      x: Math.random() * snowCanvas.width,
      y: Math.random() * snowCanvas.height,
      r: Math.random() * 2 + 1,
      speed: Math.random() * 1 + 0.5,
      drift: Math.random() * 0.5 - 0.25,
    });
  }
}

function drawSnow(wind) {
  snowCtx.clearRect(0, 0, snowCanvas.width, snowCanvas.height);
  snowCtx.fillStyle = 'rgba(255,255,255,0.7)';
  for (const s of snowflakes) {
    snowCtx.beginPath();
    snowCtx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
    snowCtx.fill();
    s.y += s.speed;
    s.x += s.drift + wind * 0.3;
    if (s.y > snowCanvas.height) { s.y = 0; s.x = Math.random() * snowCanvas.width; }
    if (s.x > snowCanvas.width) s.x = 0;
    if (s.x < 0) s.x = snowCanvas.width;
  }
}


// ═══════════════════════════════════════════════════
//  UI 업데이트
// ═══════════════════════════════════════════════════

function updateUI(p, result) {
  // 환경 오버레이
  const preset = PRESETS[p.preset];
  document.getElementById('envOverlay').innerHTML = `
    <div class="env-title">Environment Context</div>
    <div>Air: ${p.temp}°C / Road: ${p.temp - 2}°C</div>
    <div>Wind: ${p.wind} m/s / Precip: ${preset.precip}</div>
    <div>Humidity: ${preset.humidity}% / Cloud: ${preset.cloud}%</div>
    <div>Ice Risk: ${(result.iceRisk * 100).toFixed(0)}%</div>
  `;

  // 판정 박스
  const vbox = document.getElementById('verdictBox');
  vbox.textContent = result.verdict === 'CONDITIONAL' ? 'CONDITIONAL PASS' : result.verdict;
  vbox.className = `verdict-box verdict-${result.verdict}`;

  // 통계
  const covClass = result.coverageRatio >= 0.8 ? 'good' : result.coverageRatio >= 0.5 ? 'warning' : 'critical';
  document.getElementById('statsContainer').innerHTML = `
    <div class="stat-row"><span class="label">Road Area</span><span class="val">${result.totalArea.toFixed(0)} m²</span></div>
    <div class="stat-row"><span class="label">Covered</span><span class="val ${covClass}">${result.coveredArea.toFixed(0)} m²</span></div>
    <div class="stat-row"><span class="label">Coverage</span><span class="val ${covClass}">${(result.coverageRatio*100).toFixed(1)}%</span></div>
    <div class="stat-row"><span class="label">Devices</span><span class="val">${p.devCount}</span></div>
    <div class="stat-row"><span class="label">Eff. Range</span><span class="val">${result.effRange.toFixed(1)} m</span></div>
    <div class="stat-row"><span class="label">Wind Drift</span><span class="val ${Math.abs(result.drift) > 1 ? 'warning' : ''}">${result.drift.toFixed(2)} m</span></div>
    <div class="stat-row"><span class="label">Frost Depth</span><span class="val">${result.frostDepth} mm</span></div>
    <div class="stat-row"><span class="label">Burial</span><span class="val ${result.frostRisk ? 'critical' : 'good'}">${p.burial} mm</span></div>
    <div class="stat-row"><span class="label">Criticals</span><span class="val ${result.criticals > 0 ? 'critical' : 'good'}">${result.criticals}</span></div>
    <div class="stat-row"><span class="label">Warnings</span><span class="val ${result.warnings > 0 ? 'warning' : 'good'}">${result.warnings}</span></div>
  `;

  // 실패 목록
  document.getElementById('failuresContainer').innerHTML = result.failures.map(f => `
    <div class="failure-item ${f.sev === 'warning' ? 'warn' : ''}">
      <div class="title">${f.title}</div>
      <div class="desc">${f.desc}</div>
    </div>
  `).join('');

  // 결빙 위험 바
  document.getElementById('iceRiskBar').style.width = `${result.iceRisk * 100}%`;
  document.getElementById('iceRiskText').textContent = `${(result.iceRisk * 100).toFixed(0)}%`;
}

function updateSliderValues() {
  document.getElementById('tempVal').textContent = `${document.getElementById('tempSlider').value}°C`;
  document.getElementById('windVal').textContent = `${document.getElementById('windSlider').value} m/s`;
  document.getElementById('snowVal').textContent = `${document.getElementById('snowSlider').value} mm/h`;
  document.getElementById('roadLenVal').textContent = `${document.getElementById('roadLenSlider').value} m`;
  document.getElementById('lanesVal').textContent = document.getElementById('lanesSlider').value;
  document.getElementById('slopeVal').textContent = `${document.getElementById('slopeSlider').value}%`;
  document.getElementById('devCountVal').textContent = document.getElementById('devCountSlider').value;
  document.getElementById('sprayRangeVal').textContent = `${document.getElementById('sprayRangeSlider').value} m`;
  document.getElementById('sprayAngleVal').textContent = `${document.getElementById('sprayAngleSlider').value}°`;
  document.getElementById('burialVal').textContent = `${document.getElementById('burialSlider').value} mm`;
  document.getElementById('flowVal').textContent = `${document.getElementById('flowSlider').value} L/min`;
}


// ═══════════════════════════════════════════════════
//  메인 루프
// ═══════════════════════════════════════════════════

function runSim() {
  const p = getParams();
  simResult = simulate(p);
  updateUI(p, simResult);
  isRunning = true;
  simTime = 0;
  document.getElementById('simStatus').textContent = 'SIMULATING';

  const snowCount = p.snow > 0 ? Math.floor(p.snow * 30) : 0;
  initSnow(snowCount);
}

function gameLoop() {
  if (isRunning && simResult) {
    const p = getParams();
    drawSimulation(p, simResult);
    if (p.snow > 0) drawSnow(p.wind);
    else snowCtx.clearRect(0, 0, snowCanvas.width, snowCanvas.height);

    simTime += 1/60;
    const min = Math.floor(simTime / 60);
    const sec = Math.floor(simTime % 60);
    document.getElementById('timeDisplay').textContent = `T: ${String(min).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
  }
  requestAnimationFrame(gameLoop);
}

// 이벤트
document.getElementById('btnRun').addEventListener('click', runSim);
document.getElementById('btnReset').addEventListener('click', () => {
  isRunning = false;
  simResult = null;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  snowCtx.clearRect(0, 0, snowCanvas.width, snowCanvas.height);
  document.getElementById('simStatus').textContent = 'READY';
  document.getElementById('timeDisplay').textContent = 'T: 00:00';
});

// 슬라이더 실시간 업데이트
document.querySelectorAll('input[type="range"], select').forEach(el => {
  el.addEventListener('input', () => {
    updateSliderValues();
    if (isRunning) runSim();
  });
});

// 프리셋 변경 시 슬라이더 동기화
document.getElementById('presetSelect').addEventListener('change', (e) => {
  const preset = PRESETS[e.target.value];
  document.getElementById('tempSlider').value = preset.temp;
  document.getElementById('windSlider').value = preset.wind;
  document.getElementById('snowSlider').value = preset.precipMm;
  updateSliderValues();
  if (isRunning) runSim();
});

// 초기화
updateSliderValues();
gameLoop();

// 자동 시작
setTimeout(runSim, 500);
</script>
</body>
</html>
